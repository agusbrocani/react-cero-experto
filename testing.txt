NO SON UNA PÉRDIDA DE TIEMPO    
    - Garantizan la calidad
    - Detectan errores
    - Facilitan el mantenimiento
    - Aceleran el desarrollo con integraciones continuas (CI/CD)
    - Despliegues seguros
    Si me regalan un auto sin probar, ¿lo usaria?
        NO

Tipos de pruebas
    - Unitarias         : enfocadas en partes atómicas
    - Integración       : ¿cómo reaccionan varias piezas en conjunto?
    - End to End (E2E)  : ejecutan todo un flujo contínuo como si fuera el proceso que realizaría el usuario

Pruebas Unitarias
    - atómicas simples
    - no tener dependencias de otros componentes
    - debe ser especializada en lo que quiero probar

Pruebas de integración
    - ¿Cómo funcionan elementos en conjunto?
    - No deben de ser mayores a las unitarias

E2E
    - ejecutan un flujo aislado
        ej.: compra de un producto
    - objetivo específico
    - pruebas de casos improbables

Características de las pruebas automáticas
    - fácil de escribir
    - fácil de leer
    - rápidas
    - flexibles
    - principalmente unitarias

Triple A    => forma de estructurar los test
    - Arrange   => arreglar. Dejar todo listo para hacer algo con el sujeto de pruebas
        - importaciones
        - inicializaciones
    - Act       => actuar
        - aplicar estímulos
        - llamar métodos y funciones
        - simular clicks
    - Assert    => afirmar
        - ¿qué tuvo que suceder con el estímulo aplicado?   => comparo obtenido vs esperado
    
Mitos
    Hacen la app más lenta
        FALSO => se ejecuta separado
    Las pruebas NO pueden fallar
        FALSO => pueden dar falsos positivos o falsos negativos
    Hacen más lenta mi app
        FALSO => código de los test NO llegan a producción. Paso anterior a build de prod
    Es un pérdida de tiempo
        FALSO => tienen muchos beneficios
    Hay que probar todo
        FALSO => hay que testear las rutas críticas en principio, si hay tiempo, lo demás

Coverage: que tanto porcentaje del código fue testeado.
    Cobertura de líneas         : porcentaje de líneas ejecutadas
    Cobertura de ramas          : porcentaje de ramas de decisión probadas
    Cobertura de funciones      : porcentaje de funciones/métodos invocados
    Cobertura de condiciones    : porcentaje de condiciones evaluadas en ambos sentidos

IMPORTANTE: https://vitest.dev/
npm install -D vitest
Ir a package.json y agregar
    "scripts": {
        "test": "vitest",
        "test:ui": "vitest --ui",
        "coverage": "vitest run --coverage"
    }

Test de 02-first-steps
    Crear carpeta helpers dentro de src
        Crear archivo math.helper.ts
            Crear funciones add, subtract, multiply y divide
    Crear carpeta test a la misma altura que src
        Crear carpeta helpers dentro de test

Test suit === archivo .test.ts
IMPORTANTE: los archivos de test deben llamarse mismoNombre.test.ts
import {test} from 'vitest'

Si un TEST FALLA => o falló código o falló test. DEPENDE que cambió

IMPORTANTE: primero DEBO EJECUTAR npm test y luego PUEDO EJECUTAR npm run build => ahora puedo hacer deploy

Testing Library: recrear interacciones sobre los componentes de React
    Me permite montar el componente y ver lo que renderiza
    IMPORTANTE: https://testing-library.com/
    Frameworks -> React Testing Library -> Introduction -> With TypeScript
    npm install --save-dev @testing-library/react @testing-library/dom @types/react @types/react-dom
    En el archivo del test:
        import {
            render
        } from '@testing-library/react';

        Ir a vite.config.ts
            Cambiar: 
                import { defineConfig } from 'vite' 
                    por 
                import { defineConfig } from 'vitest/config'
            Agregar después de plugins: [react()]
                , test: {
                    environment: 'jsdom',
                    globals: true,
                }
        CONTROL + C
        Ejecuto npm test
        yes => Instalo dependencia 
        npm test
        Ya puedo utilizar render en el test => DESESTRUCTURO lo que necesito

    document.body       => este va a ser el DOM donde voy a renderizar cosas, equivalente al div de id root del HTML real

    const { container } = render(<MyAwesomeApp />);
    container.innerHTML => todo lo que renderiza el componente

    Ver el HTML donde se renderizó mi componente a testear
        render(<MyAwesomeApp />);
        screen.debug();

Buscar elementos en el componente renderizado
    Test con container
        0- Desestructuro container de componente utilizando el método render
            const { container } = render(<MyAwesomeApp />);
        1- Creo los tags que voy a buscar
            const h1 = container.querySelector('h1');
        
        2- Assert
            toBe: compara por igualdad estricta con tipos básicos
            expect(h1?.innerHTML).toBe('Agustín');
                h1?.innerHTML => TODO EL TEXTO que está dentro del tag h1 del componente del cual desestructuré container
            toContain: si el tipo enviado por parametro ESTA INCLUIDO da true
            // toContain: assert que da TRUE si contiene PARTE DEL TEXTO enviado por párametro
            expect(h1?.innerHTML).toContain('Agustín');
        
    IMPORTANTE: si ocurre algun evento, el container NO SE ACTUALIZA, a diferencia del screen

    Test con screen
        En el componente a testear agregar:
            <h1 data-testid="first-name-title">{firstName}</h1>
            IMPORTANTE: NO es muy buena práctica
        En el test:
                render(<MyAwesomeApp />);
                screen.debug();
                const h1 = screen.getByTestId('first-name-title');
                expect(h1.innerHTML).toContain('Agustín');
                // NO necesariamente es h1, puede ser cualquier tag, porque le puse un identificador

Snapshots: quiero verificar que el HTML (estructura física) NO CAMBIE.
    RECORDAR: eso es una penalización en el SEO.
    Es una foto del componente renderizado en un instante determinado.

    test('should match snapshot', () => {
        const { container } = render(<MyAwesomeApp />);
        expect(container).toMatchSnapshot();
    });
    LUEGO => se crea un archivo NombreDelComponente.test.tsx.snap en el directorio '__snapshots__' dentro de la carpeta test
    IMPORTANTE: DEBO actualizar snapshots si cambié la estructura del return del componente
    IMPORTANTE: usar snapshort SOLO si el componente NO VA A CAMBIAR a lo largo del tiempo

IMPORTANTE: PROBAR de mi más fácil a lo más complejo

Verificar existencia en TODO el DOM:
    expect(screen.getByText(name)).toBeDefined();
    expect(screen.getByText(name)).not.toBeNull();

Disparar eventos
    Evento click
        const buttonAdd = screen.getByText('+1');
        // Disparo el evento del tag seleccionado
        fireEvent.click(buttonAdd);
        expect(screen.getByText('2', { selector: 'span' })).toBeDefined();

Comprobar estilos
    Utilizando .style.color
    test('should change to red when count is 0', () => {
        const quantity = 0;
        const name = 'Test item'
        render(<ItemCounter name={name} quantity={quantity} />);

        const itemText = screen.getByText(name);

        expect(itemText.style.color).toBe('red');
    });

Mocks de componentes: llamar al componente sin renderizarlo
    IMPORTANTE: es importante NO RENDERIZARLO para no hacer llamadas a APIs por ej.
    
    Evito que se renderice el modulo
    import { vi } from 'vitest';
    vi.mock('../src/shopping-cart/ItemCounter', () => ({
        default: () => <div data-testid="ItemCounter" />
    }));

    import { FirstStepsApp } from '../src/FirstStepsApp';
    IMPORTANTE: si utilicé export default en ItemCounter, DEBO UTILIZAR default en el objeto del mock.
        Si NO UTILICE export default, debo utilizar 'ItemCounter' o el nombre que tenga el componente.
    IMPORTANTE: se puede usar 1 SOLO EXPORT DEFAULT por archivo.
    IMPORTANTE: debo realizar 1 funcion de mock por cada componente importado
    
    Testear cantidad de renderizados toHaveBeenCalledTimes y parametros de renderizado con toHaveBeenCalledWith
        const mockItemCounter = vi.fn((props: unknown) => {
            return (
                <div data-testid="ItemCounter" />
            );
        });

        vi.mock('../src/shopping-cart/ItemCounter', () => ({
            default: (props: unknown) => mockItemCounter(props)
        }));

        test('should render ItemCounter with correct props', () => {
            render(<FirstStepsApp />);
            expect(mockItemCounter).toHaveBeenCalledTimes(itemsInCart.length);  // falla porque se renderizo 9 veces, 3 por cada test. Debo limpiar los mocks con afterEach
            expect(mockItemCounter).toHaveBeenCalledWith({
            name: 'Nintendo Switch 2',
            quantity: 1,
            });
        });
    
    IMPORTANTE: debo utilizar afterEach luego de renderizar componentes mockeados
        afterEach(() => {
            vi.clearAllMocks();
        });

Índice de Cobertura
    npm run test:ui
        => instalo dependencias
    => ejecuto nuevamente
        PROCEDO A VER DASHBOARD EN BROWSER
    npm run coverage
        => instalo dependencias
    => ejecuto nuevamente
        - PROCEDO A VER MÉTRICAS EN TERMINAL
        - se creó carpeta de coverage
            => abrir index.html de esa carpeta con un navegador

CÓDIGO FUENTE: https://github.com/DevTalles-corp/react-first-steps/tree/fin-seccion-05
